generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Organization {
  id   String @id @default(uuid())
  name String

  users       User[]
  regions     Region[]
  teams       Team[]
  timeEntries TimeEntry[] @relation("OrgTimeEntries") // <- nombre explícito

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Region {
  id             String       @id @default(uuid())
  name           String
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  managerId String?
  manager   User?   @relation("RegionManager", fields: [managerId], references: [id]) // <- nombre agregado

  teams       Team[]
  timeEntries TimeEntry[] @relation("RegionTimeEntries")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Team {
  id   String @id @default(uuid())
  name String

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  regionId String?
  region   Region? @relation(fields: [regionId], references: [id], onDelete: Cascade)

  managerId String
  manager   User   @relation("TeamManager", fields: [managerId], references: [id])

  members     TeamMember[]
  timeEntries TimeEntry[]  @relation("TeamTimeEntries") // <- nombre explícito

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model TeamMember {
  id String @id @default(uuid())

  teamId String
  team   Team   @relation(fields: [teamId], references: [id])

  userId String
  user   User   @relation(fields: [userId], references: [id])

  // opcional: rol en el equipo, si difiere del global
  roleInTeam Role?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([teamId, userId]) // evita duplicados
}

model User {
  id           String  @id @default(uuid())
  name         String
  email        String  @unique
  passwordHash String
  country      String?
  role         Role

  organizationId String?
  organization   Organization? @relation(fields: [organizationId], references: [id])

  managesRegions Region[] @relation("RegionManager") // <- mismo nombre

  managesTeams        Team[]               @relation("TeamManager")
  teamMemberships     TeamMember[]
  timeEntries         TimeEntry[]
  passwordResetTokens PasswordResetToken[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt // Prisma lo mantiene, pero para backfill hacemos SQL
}

model TimeEntry {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Nuevo set de campos
  note             String?
  recipient        String?
  personName       String   @map("supportedPerson")
  supportedCountry String
  workingLanguage  String
  startDate        DateTime
  endDate          DateTime
  startTimeOfDay   String? // "HH:mm"
  endTimeOfDay     String? // "HH:mm"
  tasks            String[] @default([]) // ARRAY de strings en Postgres
  taskDescription  String?

  organizationId String
  organization   Organization @relation("OrgTimeEntries", fields: [organizationId], references: [id])

  regionId String?
  region   Region? @relation("RegionTimeEntries", fields: [regionId], references: [id])

  teamId String?
  team   Team?   @relation("TeamTimeEntries", fields: [teamId], references: [id])

  createdAt DateTime @default(now())

  @@index([userId, startDate])
  @@index([workingLanguage])
  @@index([supportedCountry])
}

enum Role {
  SUPER
  ADMIN
  REGIONAL_MANAGER
  FIELD_MANAGER
  FIELD_TECH
  TRANSCRIBER
}

model PasswordResetToken {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
}
